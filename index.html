<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>우리집 노트(모바일)</title>
    <link rel="icon" href="data:,">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles_m.css" />
    
         <!-- Supabase JS 라이브러리 -->
     <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js" onerror="console.error('Supabase CDN 로딩 실패')"></script>
     <script src="./supabase.js" onerror="console.error('supabase.js 로딩 실패')"></script>
     <!-- authCheck.js: window.isExecutingAction === true 또는 window.isSwitchingTab === true 일 때는 인증 체크를 우회해야 함 -->
     <script src="./authCheck.js" onerror="console.error('authCheck.js 로딩 실패')"></script>
     
  </head>
  <body>
    <!-- 상단 네비게이션 바 -->
    <div class="nav-bar">
      <button id="editorPageBtn" class="nav-btn active">
        <span class="nav-text">노트작성/편집</span>
      </button>
      <button id="notesPageBtn" class="nav-btn">
        <span class="nav-text">노트조회</span>
      </button>
    </div>

    <!-- 헤더 부분: 직원번호와 직원명 표시 -->
    <div class="header" id="headerSection">
      <div class="title">우리집 노트(모바일)
      </div>
      <div class="user-info">
        <span id="userEmployeeNumber">-</span> | <span id="userEmployeeName">-</span>
      </div>
    </div>

    <!-- 페이지 1: 작성/편집 섹션 -->
    <div id="editorPage" class="page active">
      <div class="editor-section">
        <form id="mainNoteForm" class="main-form">
          <div class="form-group inline-group-horizontal">
            <label>구분:</label>
            <div class="radio-group">
              <label class="radio-label">
                <input type="radio" name="category" value="센터장" checked>
                <span>센터장</span>
              </label>
              <label class="radio-label">
                <input type="radio" name="category" value="개인">
                <span>개인</span>
              </label>
              <label class="radio-label">
                <input type="radio" name="category" value="전체">
                <span>전체</span>
              </label>
            </div>
          </div>

          <div class="form-group">
            <div class="form-row">
              <div class="form-col">
                <label for="mainDate">노트날짜:</label>
                <input type="date" id="mainDate" required>
              </div>
              <div class="form-col">
                <label for="mainNumber">노트번호:</label>
                <input type="text" id="mainNumber" readonly>
              </div>
            </div>
          </div>

          <div class="form-group">
            <div class="tag-input-wrapper">
              <div class="tag-input-row">
                <label for="mainTag">태그:</label>
                <input type="text" id="mainTag" class="tag-input-field" placeholder="태그를 입력하고 Enter를 누르세요">
                <input type="hidden" id="mainTagHidden">
              </div>
              <div class="tag-chips" id="mainTagChips"></div>
            </div>
            <div class="tag-examples">
              <span class="tag-label">예시:</span>
              <button type="button" class="tag-example-btn" data-target="mainTag" data-tag="회원상담">회원상담</button>
              <button type="button" class="tag-example-btn" data-target="mainTag" data-tag="보호자요청">보호자요청</button>
              <button type="button" class="tag-example-btn" data-target="mainTag" data-tag="회원요청">회원요청</button>
              <button type="button" class="tag-example-btn" data-target="mainTag" data-tag="회원이슈">회원이슈</button>
              <button type="button" class="tag-example-btn" data-target="mainTag" data-tag="준비사항">준비사항</button>
            </div>
          </div>

          <div class="form-group textarea-container">
            <label for="mainContent">노트내용:</label>
            <textarea id="mainContent" rows="8" required placeholder="노트 내용을 입력하세요"></textarea>
          </div>

          <!-- 게시여부 -->
          <div class="form-group publish-container">
            <div class="inline-group-horizontal">
              <label>게시여부:</label>
              <div class="radio-group">
                <label class="radio-label">
                  <input type="radio" name="publish" value="Y" checked>
                  <span>Y</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="publish" value="N">
                  <span>N</span>
                </label>
              </div>
            </div>
          </div>

          <!-- 버튼 영역 -->
          <div class="button-section">
            <button type="button" id="resetMainBtn" class="action-btn reset-btn">초기화</button>
            <button type="button" id="saveMainBtn" class="action-btn save-btn">저장</button>
            <button type="button" id="editMainBtn" class="action-btn edit-btn" disabled>수정</button>
            <button type="button" id="deleteMainBtn" class="action-btn delete-btn" disabled>삭제</button>
          </div>
        </form>
      </div>
      </div>
    </div>

    <!-- 페이지 2: 노트 조회 섹션 -->
    <div id="notesPage" class="page">
      <!-- 검색 영역 -->
      <div class="search-section">
        <div class="search-controls">
          <!-- 첫 번째 줄: 날짜 범위 -->
          <div class="search-row">
            <div class="search-field">
              <label>시작일:</label>
              <input type="date" id="searchStartDate" placeholder="시작일 선택">
            </div>
            <div class="search-field">
              <label>종료일:</label>
              <input type="date" id="searchEndDate" placeholder="종료일 선택">
            </div>
          </div>

          <!-- 두 번째 줄 -->
          <div class="search-row">
            <div class="search-field">
              <label>태그:</label>
              <input type="text" id="searchTag" placeholder="태그 검색">
            </div>
            <div class="search-field">
              <label>내용:</label>
              <input type="text" id="searchContent" placeholder="내용 검색">
            </div>
          </div>
          
          <!-- 세 번째 줄: 직원명 검색 + 공개여부 필터 -->
          <div class="search-row">
            <div class="search-field">
              <label>직원명:</label>
              <input type="text" id="searchAuthor" placeholder="직원명 검색">
            </div>
            <div class="publish-filter">
              <label>보기:</label>
              <div class="radio-group">
                <label class="radio-label">
                  <input type="radio" name="publishFilter" value="published" checked>
                  <span>게시만</span>
                </label>
                <label class="radio-label">
                  <input type="radio" name="publishFilter" value="all">
                  <span>전체</span>
                </label>
              </div>
            </div>
          </div>
          
          <!-- 네 번째 줄: 검색 버튼 -->
          <div class="search-row">
            <div class="search-buttons">
              <button id="searchBtn">검색</button>
              <button id="resetBtn">초기화</button>
            </div>
          </div>
        </div>
      </div>

      <!-- 노트 목록 -->
      <div class="notes-list">
        <div id="notesContainer">
          <!-- 동적으로 노트 카드들이 들어갈 곳 -->
        </div>
      </div>
    </div>

    <!-- 커스텀 Alert 모달 -->
    <div id="customAlertModal" class="custom-modal">
      <div class="custom-modal-content alert-modal">
        <div class="custom-modal-header">
          <h3>알림</h3>
        </div>
        <div class="custom-modal-body">
          <p id="alertMessage"></p>
        </div>
        <div class="custom-modal-footer">
          <button type="button" id="alertOkBtn" class="custom-btn primary-btn">확인</button>
        </div>
      </div>
    </div>

    <!-- 커스텀 Confirm 모달 -->
    <div id="customConfirmModal" class="custom-modal">
      <div class="custom-modal-content confirm-modal">
        <div class="custom-modal-header">
          <h3>확인</h3>
        </div>
        <div class="custom-modal-body">
          <p id="confirmMessage"></p>
        </div>
        <div class="custom-modal-footer">
          <button type="button" id="confirmCancelBtn" class="custom-btn secondary-btn">취소</button>
          <button type="button" id="confirmOkBtn" class="custom-btn primary-btn">확인</button>
        </div>
      </div>
    </div>

    <!-- 숨겨진 userInfo 요소 (parent page에서 사번 가져오기용) -->
    <div id="userInfo" style="display: none;"></div>

    <script>
      // 전역 변수
      let currentUser = '';
      let currentUserName = '';
      let selectedNoteId = null;
      let notes = [];
      let isEditMode = false;
      let isViewMode = false;
      
      // 직원 정보 캐시
      let employeesCache = null;
      let employeesCacheLoaded = false;
      
      // 날짜 필터 관련 변수
      let cachedNotes = []; // 서버에서 가져온 원본 데이터
      let currentDateRange = { startDate: '', endDate: '' }; // 현재 설정된 날짜 범위

      // 페이지 상태 변수
      let currentPage = 'editor'; // 'notes' 또는 'editor'

      // 한국 시간 기준 날짜 유틸리티 함수들
      function getKoreaDate() {
        const now = new Date();
        const koreaOffset = 9 * 60; // UTC+9 (분 단위)
        const utc = now.getTime() + (now.getTimezoneOffset() * 60000);
        const koreaTime = new Date(utc + (koreaOffset * 60000));
        return koreaTime;
      }

      function getKoreaDateString(date = null) {
        const koreaDate = date || getKoreaDate();
        return koreaDate.toISOString().split('T')[0]; // yyyy-mm-dd 형식
      }

      function getKoreaDateStringForDB(date = null) {
        const dateStr = getKoreaDateString(date);
        return dateStr.replace(/-/g, ''); // yyyymmdd 형식
      }

      function getDateDaysAgo(days) {
        const koreaDate = getKoreaDate();
        koreaDate.setDate(koreaDate.getDate() - days);
        return koreaDate;
      }

      function initializeDateRange() {
        const today = getKoreaDateString();
        const twoWeeksAgo = getKoreaDateString(getDateDaysAgo(14));
        
        currentDateRange.startDate = twoWeeksAgo;
        currentDateRange.endDate = today;
        
        return { startDate: twoWeeksAgo, endDate: today };
      }

      // 직원 정보 초기화 및 캐싱 (모바일 최적화)
      async function initializeEmployeesCache() {
        if (employeesCacheLoaded) {
          return employeesCache;
        }
        
        try {
          console.log('📋 직원 정보 로딩 중...');
          
          // 모바일에서 네트워크 타임아웃 처리
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('네트워크 연결 시간 초과')), 10000);
          });
          
          const employeesPromise = getEmployeesInfo();
          employeesCache = await Promise.race([employeesPromise, timeoutPromise]);
          
          employeesCacheLoaded = true;
          console.log('✅ 직원 정보 로딩 완료:', employeesCache.length, '명');
          return employeesCache;
        } catch (error) {
          console.error('❌ 직원 정보 로딩 실패:', error);
          employeesCache = [];
          employeesCacheLoaded = true;
          
          // 모바일에서 네트워크 오류 시 사용자에게 알림
          if (isMobileDevice()) {
            console.warn('📱 모바일 환경에서 직원 정보 로딩 실패');
          }
          
          return employeesCache;
        }
      }

      // 캐시된 직원 정보에서 직원명 찾기
      function getEmployeeNameFromCache(employeeNumber) {
        if (!employeesCacheLoaded || !employeesCache) {
          return employeeNumber; // 캐시가 로딩되지 않았으면 직원번호 반환
        }
        
        let employee = employeesCache.find(emp => emp.직원번호 === employeeNumber);
        
        if (!employee) {
          employee = employeesCache.find(emp => 
            emp.직원번호 && emp.직원번호.toLowerCase() === employeeNumber.toLowerCase()
          );
        }
        
        return employee ? employee.직원명 : employeeNumber;
      }

      // 직원 유효성 검사 함수
      function isValidEmployee(employeeNumber) {
        if (!employeeNumber) {
          return false;
        }

        if (!employeesCacheLoaded || !employeesCache) {
          return false;
        }

        if (employeeNumber === 'admin' || employeeNumber === 's25001') {
          return true;
        }

        const employee = employeesCache.find(emp => 
          emp.직원번호 && emp.직원번호.toLowerCase() === employeeNumber.toLowerCase()
        );

        return !!employee;
      }

      // 페이지 전체 비활성화 함수 (모바일용)
      function disablePageForUnauthorizedUser() {
        console.log('🚫 무효한 직원번호 - 페이지 전체 비활성화');
        
        // 모든 입력 요소 비활성화
        const allInputs = document.querySelectorAll('input, textarea, button, select');
        allInputs.forEach(element => {
          element.disabled = true;
        });
        
        // 네비게이션 버튼 비활성화
        const navBtns = document.querySelectorAll('.nav-btn');
        navBtns.forEach(btn => {
          btn.style.pointerEvents = 'none';
          btn.style.opacity = '0.5';
        });
        
        // 노트 카드 클릭 이벤트 제거
        const noteCards = document.querySelectorAll('.note-card');
        noteCards.forEach(card => {
          card.style.pointerEvents = 'none';
          card.style.opacity = '0.5';
        });
        
        // 모바일용 비활성화 오버레이 추가
        if (!document.getElementById('unauthorizedOverlay')) {
          const overlay = document.createElement('div');
          overlay.id = 'unauthorizedOverlay';
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
            font-size: 1rem;
            text-align: center;
            font-family: "Noto Sans KR", "맑은 고딕", "Malgun Gothic", sans-serif;
            padding: 1rem;
            box-sizing: border-box;
          `;
          
          overlay.innerHTML = `
            <div style="background: #fff; color: #333; padding: 1.5rem; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 320px; width: 90%;">
              <h3 style="color: #e74c3c; margin-bottom: 1rem; font-size: 1.1rem;">⚠️ 접근 권한 없음</h3>
              <p style="margin-bottom: 1rem; font-size: 0.9rem; line-height: 1.4;">직원명단에 등록되지 않은 사용자입니다.</p>
              <p style="font-size: 0.8rem; color: #666; line-height: 1.3;">관리자에게 문의하시기 바랍니다.</p>
              <p style="font-size: 0.7rem; color: #999; margin-top: 1rem; word-break: break-all;">현재 사용자: ${currentUser}</p>
            </div>
          `;
          
          document.body.appendChild(overlay);
        }
        
        // 헤더의 사용자 정보도 업데이트
        document.getElementById('userEmployeeNumber').textContent = currentUser;
        document.getElementById('userEmployeeName').textContent = '권한 없음';
      }

      // 페이지 활성화 함수 (유효한 사용자용)
      function enablePageForAuthorizedUser() {
        console.log('✅ 유효한 직원번호 - 페이지 활성화');
        
        // 기존 오버레이 제거
        const overlay = document.getElementById('unauthorizedOverlay');
        if (overlay) {
          overlay.remove();
        }
        
        // 모든 입력 요소 활성화 (단, readonly는 유지)
        const allInputs = document.querySelectorAll('input, textarea, button, select');
        allInputs.forEach(element => {
          if (!element.hasAttribute('readonly')) {
            element.disabled = false;
          }
        });
        
        // 네비게이션 버튼 활성화
        const navBtns = document.querySelectorAll('.nav-btn');
        navBtns.forEach(btn => {
          btn.style.pointerEvents = 'auto';
          btn.style.opacity = '1';
        });
        
        // 노트 카드 클릭 이벤트 복원
        const noteCards = document.querySelectorAll('.note-card');
        noteCards.forEach(card => {
          card.style.pointerEvents = 'auto';
          card.style.opacity = '1';
        });
      }

      // 사용자 정보를 저장소에 저장하는 함수
      function saveUserInfoToStorage(userInfo) {
        if (userInfo && userInfo.trim()) {
          try {
            sessionStorage.setItem('currentUser', userInfo.trim());
            sessionStorage.setItem('userInfo', userInfo.trim());
            sessionStorage.setItem('empNo', userInfo.trim());
            
            localStorage.setItem('currentUser', userInfo.trim());
            localStorage.setItem('userInfo', userInfo.trim());
            localStorage.setItem('empNo', userInfo.trim());
            
            console.log('💾 사용자 정보 저장 완료:', userInfo.trim());
          } catch (error) {
            console.error('사용자 정보 저장 에러:', error);
          }
        }
      }

             // 전역 변수: 작업 실행 중 flag (authCheck 우회용으로 window 객체에도 노출)
       let isExecutingAction = false;
       let isSwitchingTab = false; // 탭 전환 중 플래그 추가
       
       // authCheck.js가 참조할 수 있도록 전역으로 노출
       window.isExecutingAction = false;
       window.isSwitchingTab = false;

      // parent page에서 사용자 정보 가져오기 함수 (개선된 버전)
      async function getUserFromParent(skipParentCheck = false) {
        try {
          // 작업 실행 중이거나 탭 전환 중일 때는 parent 체크를 건너뛸 수 있도록 함
          if (skipParentCheck || isExecutingAction || isSwitchingTab) {
            console.log('🔄 작업 실행 중이거나 탭 전환 중이므로 기존 사용자 정보 유지:', currentUser);
            if (currentUser && currentUser.trim()) {
              return;
            }
          }

          // 새로운 로그인 감지를 위해 parent에서 먼저 확인
          let newUserFromParent = null;
          
          // 방법 1: parent window에서 직접 접근하여 최신 정보 확인 (안전하게 처리)
          if (window.parent && window.parent !== window && !skipParentCheck) {
            try {
              // Cross-origin 접근 제한을 고려하여 안전하게 처리
              const parentUserInfo = window.parent.document.getElementById('userInfo');
              if (parentUserInfo) {
                // data-emp-no 속성에서 먼저 시도
                const empNoFromData = parentUserInfo.getAttribute('data-emp-no');
                if (empNoFromData && empNoFromData.trim()) {
                  newUserFromParent = empNoFromData.trim();
                  console.log('🔍 Parent에서 최신 사용자 정보 확인:', newUserFromParent);
                }
                
                // textContent에서 직원번호 추출 시도
                if (!newUserFromParent) {
                  const textContent = parentUserInfo.textContent.trim();
                  if (textContent && !textContent.includes('로그인이 필요합니다')) {
                    const match = textContent.match(/([A-Za-z0-9]+)\s*님/);
                    if (match) {
                      newUserFromParent = match[1].toLowerCase();
                      console.log('🔍 Parent textContent에서 최신 사용자 정보 확인:', newUserFromParent);
                    }
                  }
                }
              }
            } catch (error) {
              console.log('Parent 접근 실패 (Cross-origin 제한 가능성), 다른 방법 시도');
            }
          }
          
          // 새로운 사용자 정보가 있고 기존과 다르면 캐시 초기화 (단, 작업 실행 중이거나 탭 전환 중이 아닐 때만)
          if (newUserFromParent && newUserFromParent !== currentUser && !isExecutingAction && !isSwitchingTab) {
            console.log('🔄 사용자 변경 감지:', currentUser, '→', newUserFromParent);
            console.log('🗑️ 기존 캐시 정보 삭제');
            
            // 기존 캐시된 정보 모두 삭제
            currentUser = '';
            currentUserName = '';
            selectedNoteId = null;
            notes = [];
            cachedNotes = [];
            
            // 직원 정보 캐시도 초기화
            employeesCache = null;
            employeesCacheLoaded = false;
            
            // 저장소에서 기존 정보 삭제
            try {
              sessionStorage.clear();
              localStorage.removeItem('currentUser');
              localStorage.removeItem('userInfo');
              localStorage.removeItem('empNo');
            } catch (error) {
              console.error('캐시 삭제 중 오류:', error);
            }
            
            // 새로운 사용자 정보 설정
            currentUser = newUserFromParent;
            saveUserInfoToStorage(currentUser);
            console.log('✅ 새로운 사용자 정보로 설정:', currentUser);
            return;
          }
          
          // 방법 0: 이미 currentUser가 설정되어 있고 변경이 없다면 재사용
          if (currentUser && currentUser.trim()) {
            console.log('🔄 기존 사용자 정보 재사용:', currentUser);
            return;
          }

          // 방법 2: sessionStorage에서 확인 (새로고침 대응)
          const sessionUser = sessionStorage.getItem('currentUser') || 
                             sessionStorage.getItem('userInfo') || 
                             sessionStorage.getItem('empNo');
          if (sessionUser && sessionUser.trim()) {
            currentUser = sessionUser.trim();
            console.log('✅ sessionStorage에서 사용자 정보 복원:', currentUser);
            saveUserInfoToStorage(currentUser);
            return;
          }

          const userInfoElement = document.getElementById('userInfo');
          if (userInfoElement && userInfoElement.textContent.trim()) {
            currentUser = userInfoElement.textContent.trim();
            console.log('✅ 현재 페이지 userInfo에서 가져옴:', currentUser);
            saveUserInfoToStorage(currentUser);
            return;
          }

          const urlParams = new URLSearchParams(window.location.search);
          const userParam = urlParams.get('user') || urlParams.get('userId') || urlParams.get('empNo');
          if (userParam) {
            currentUser = userParam.trim();
            console.log('✅ URL 파라미터에서 가져옴:', currentUser);
            saveUserInfoToStorage(currentUser);
            return;
          }

          const localUser = localStorage.getItem('userInfo') || localStorage.getItem('currentUser') || localStorage.getItem('empNo');
          if (localUser) {
            currentUser = localUser.trim();
            console.log('✅ localStorage에서 가져옴:', currentUser);
            saveUserInfoToStorage(currentUser);
            return;
          }

          // 방법 6: postMessage로 parent에게 요청 (안전하게 처리)
          if (window.parent && window.parent !== window && !skipParentCheck) {
            try {
              return new Promise((resolve) => {
                const timeout = setTimeout(() => {
                  currentUser = 'test001';
                  console.log('⚠️ parent 응답 시간 초과, 기본값 사용:', currentUser);
                  saveUserInfoToStorage(currentUser);
                  resolve();
                }, 1000); // 시간 단축 (2000 → 1000)

                window.addEventListener('message', function(event) {
                  if (event.data && event.data.type === 'userInfo') {
                    clearTimeout(timeout);
                    currentUser = event.data.userId || event.data.empNo || event.data.user || 'test001';
                    console.log('✅ postMessage로 가져옴:', currentUser);
                    saveUserInfoToStorage(currentUser);
                    resolve();
                  }
                }, { once: true });

                try {
                  window.parent.postMessage({ type: 'requestUserInfo' }, '*');
                } catch (postError) {
                  console.log('postMessage 전송 실패:', postError);
                  clearTimeout(timeout);
                  currentUser = 'test001';
                  saveUserInfoToStorage(currentUser);
                  resolve();
                }
              });
            } catch (error) {
              console.log('postMessage 처리 중 오류:', error);
            }
          }

          // 모든 방법 실패 시 기본값
          currentUser = 'test001';
          console.log('⚠️ 모든 방법 실패, 기본값 사용:', currentUser);
          saveUserInfoToStorage(currentUser);

        } catch (error) {
          console.error('사용자 정보 가져오기 에러:', error);
          currentUser = 'test001';
          saveUserInfoToStorage(currentUser);
        }
      }

      // 직원 정보 로드 (캐시 사용)
      async function loadUserInfo() {
        try {
          console.log('=== 직원 정보 로드 시작 ===');
          console.log('현재 사용자:', currentUser);
          
          if (!employeesCacheLoaded) {
            console.log('직원 캐시가 로딩되지 않음 - 초기화 시작');
            await initializeEmployeesCache();
          }
          
          currentUserName = getEmployeeNameFromCache(currentUser);
          console.log('조회된 직원명:', currentUserName);
          
          if (currentUserName === currentUser) {
            currentUserName = '알 수 없음';
            console.log('직원명을 찾지 못함 - "알 수 없음"으로 설정');
          }

          document.getElementById('userEmployeeNumber').textContent = currentUser;
          document.getElementById('userEmployeeName').textContent = currentUserName;
          
          console.log('=== 직원 정보 로드 완료 ===');
        } catch (error) {
          console.error('직원 정보 로드 실패:', error);
          currentUserName = '알 수 없음';
          document.getElementById('userEmployeeNumber').textContent = currentUser;
          document.getElementById('userEmployeeName').textContent = currentUserName;
        }
      }

      // 페이지 전환 함수
      function switchToPage(pageName) {
        // 탭 전환 시작 플래그 설정 (authCheck 우회용)
        isSwitchingTab = true;
        window.isSwitchingTab = true;
        console.log('🔄 탭 전환 시작:', pageName, '- authCheck 우회 활성화');
        
        const pages = document.querySelectorAll('.page');
        const navBtns = document.querySelectorAll('.nav-btn');
        
        pages.forEach(page => page.classList.remove('active'));
        navBtns.forEach(btn => btn.classList.remove('active'));
        
        document.getElementById(pageName + 'Page').classList.add('active');
        document.getElementById(pageName + 'PageBtn').classList.add('active');
        
        currentPage = pageName;
        console.log('페이지 전환:', pageName);
        
        // 편집 페이지로 전환할 때 textarea 높이 재계산
        if (pageName === 'editor') {
          setTimeout(() => {
            calculateOptimalTextareaHeight();
          }, 100);
        }
        
        // 탭 전환 완료 후 플래그 해제 (지연 실행)
        setTimeout(() => {
          isSwitchingTab = false;
          window.isSwitchingTab = false;
          console.log('✅ 탭 전환 완료 - authCheck 우회 해제');
        }, 500); // 충분한 시간을 두어 탭 전환이 완전히 완료되도록 함
      }

      // 노트 목록 로드 (모바일 최적화)
      async function loadNotes() {
        try {
          console.log('📝 === 노트 목록 로드 시작 ===');
          
          if (!isValidEmployee(currentUser)) {
            console.log('🚫 직원명단에 없는 사용자입니다. 페이지 전체를 비활성화합니다.');
            cachedNotes = [];
            displayNotes(cachedNotes);
            disablePageForUnauthorizedUser();
            return;
          } else {
            enablePageForAuthorizedUser();
          }
          
          if (!currentDateRange.startDate || !currentDateRange.endDate) {
            initializeDateRange();
          }
          
          console.log('📅 날짜 범위:', currentDateRange);
          console.log('👤 현재 사용자:', currentUser);
          
          // 모바일에서 네트워크 타임아웃 처리
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error('노트 로딩 시간 초과')), 15000);
          });
          
          const notesPromise = getNoteshareDataByDateRange(
            currentUser, 
            currentDateRange.startDate, 
            currentDateRange.endDate
          );
          
          cachedNotes = await Promise.race([notesPromise, timeoutPromise]);
          
          console.log('📊 서버에서 조회된 노트 수:', cachedNotes.length);
          
          const publishFilter = document.querySelector('input[name="publishFilter"]:checked')?.value || 'published';
          const filteredNotes = applyPublishFilter(cachedNotes, publishFilter);
          
          notes = filteredNotes;
          displayNotes(notes);
          
          console.log('✅ === 노트 목록 로드 완료 ===');
        } catch (error) {
          console.error('❌ 노트 로드 실패:', error);
          
          // 모바일 환경에서 더 자세한 오류 처리
          if (isMobileDevice()) {
            if (error.message.includes('시간 초과')) {
              await customAlert('네트워크가 느려 노트를 불러오는데 시간이 오래 걸리고 있습니다. 잠시 후 다시 시도해주세요.');
            } else {
              await customAlert('노트를 불러오는데 실패했습니다. 네트워크 연결을 확인해주세요.');
            }
          } else {
            await customAlert('노트를 불러오는데 실패했습니다.');
          }
          
          // 오류 시에도 빈 목록 표시
          cachedNotes = [];
          notes = [];
          displayNotes(notes);
        }
      }

      // 게시여부 필터 적용
      function applyPublishFilter(notesList, publishFilter) {
        if (publishFilter === 'published') {
          return notesList.filter(note => note.게시여부 === 'Y');
        } else {
          return notesList;
        }
      }

      // 클라이언트 사이드 필터링 (태그, 내용, 직원명)
      function applyClientSideFilters(notesList, filters) {
        let filtered = [...notesList];
        
        if (filters.tag && filters.tag.trim()) {
          const tagKeyword = filters.tag.trim().toLowerCase();
          filtered = filtered.filter(note => 
            note.태그 && note.태그.toLowerCase().includes(tagKeyword)
          );
        }
        
        if (filters.content && filters.content.trim()) {
          const contentKeyword = filters.content.trim().toLowerCase();
          filtered = filtered.filter(note => 
            note.노트내용 && note.노트내용.toLowerCase().includes(contentKeyword)
          );
        }
        
        if (filters.author && filters.author.trim()) {
          const authorKeyword = filters.author.trim().toLowerCase();
          filtered = filtered.filter(note => {
            let authorName = note.직원명;
            if (!authorName || authorName === note.직원번호) {
              authorName = getEmployeeNameFromCache(note.직원번호);
            }
            return authorName && authorName.toLowerCase().includes(authorKeyword);
          });
        }
        
        return filtered;
      }

      // 날짜 범위가 변경되었는지 확인
      function hasDateRangeChanged(newStartDate, newEndDate) {
        return currentDateRange.startDate !== newStartDate || 
               currentDateRange.endDate !== newEndDate;
      }

      // 날짜 형식 변환 함수들
      function formatDateForInput(dateString) {
        if (!dateString || dateString.length !== 8) return '';
        const year = dateString.substring(0, 4);
        const month = dateString.substring(4, 6);
        const day = dateString.substring(6, 8);
        return `${year}-${month}-${day}`;
      }

      function formatDateForStorage(dateString) {
        if (!dateString) return '';
        return dateString.replace(/-/g, '');
      }

      function formatDateForDisplay(dateString) {
        if (!dateString || dateString.length !== 8) return '';
        const year = dateString.substring(2, 4);
        const month = dateString.substring(4, 6);
        const day = dateString.substring(6, 8);
        return `${year}.${month}.${day}`;
      }

      // 노트 목록 표시 (카드 형태)
      function displayNotes(notesToDisplay) {
        const container = document.getElementById('notesContainer');
        container.innerHTML = '';

        if (notesToDisplay.length === 0) {
          container.innerHTML = '<div class="no-notes">조회된 노트가 없습니다.</div>';
          return;
        }

        // 기본 정렬: 노트날짜 내림차순, 직원명 오름차순, 번호 오름차순
        const sortedNotes = [...notesToDisplay].sort((a, b) => {
          const dateA = a.노트날짜 || '';
          const dateB = b.노트날짜 || '';
          if (dateA !== dateB) {
            return dateB.localeCompare(dateA);
          }
          
          const nameA = a.직원명 || getEmployeeNameFromCache(a.직원번호) || a.직원번호 || '';
          const nameB = b.직원명 || getEmployeeNameFromCache(b.직원번호) || b.직원번호 || '';
          if (nameA !== nameB) {
            return nameA.localeCompare(nameB);
          }
          
          const numberA = a.노트번호 || '';
          const numberB = b.노트번호 || '';
          return numberA.localeCompare(numberB);
        });

        sortedNotes.forEach(note => {
          const noteCard = document.createElement('div');
          noteCard.className = 'note-card';
          noteCard.setAttribute('data-note-id', note.id);
          
          const displayDate = formatDateForDisplay(note.노트날짜 || '');
          
          let authorName = note.직원명;
          if (!authorName || authorName === note.직원번호) {
            authorName = getEmployeeNameFromCache(note.직원번호);
          }
          
          const noteSequence = extractNoteSequence(note.노트번호);
          
          noteCard.innerHTML = `
            <div class="note-header">
              <div class="note-meta">
                <span class="note-category">${note.구분 || '-'}</span>
                <span class="note-date">${displayDate}</span>
                <span class="note-author">${authorName || note.직원번호 || '-'}</span>
                <span class="note-number">#${noteSequence}</span>
              </div>
              <div class="note-publish ${note.게시여부 === 'N' ? 'private' : 'published'}">
                ${note.게시여부 === 'N' ? '🔒' : '🌐'}
              </div>
            </div>
            <div class="note-tags">
              ${note.태그 ? note.태그.split(',').map(tag => `<span class="tag">${tag.trim()}</span>`).join('') : '<span class="no-tag">태그 없음</span>'}
            </div>
            <div class="note-content">
              ${note.노트내용 || ''}
            </div>
          `;
          
          // 카드 더블클릭 이벤트 (모바일에서 실수 클릭 방지)
          noteCard.addEventListener('dblclick', () => {
            selectNoteForEdit(note);
          });

          // 싱글 터치/클릭 시 선택 표시만
          noteCard.addEventListener('click', () => {
            // 기존 선택 해제
            document.querySelectorAll('.note-card').forEach(card => {
              card.classList.remove('selected');
            });
            // 현재 카드 선택 표시
            noteCard.classList.add('selected');
          });
          
          container.appendChild(noteCard);
        });
      }

      // 노트번호에서 마지막 번호만 추출
      function extractNoteSequence(noteNumber) {
        if (!noteNumber) return '-';
        const parts = noteNumber.split('-');
        return parts.length > 0 ? parts[parts.length - 1] : '-';
      }

      // 노트 선택하여 편집 모드로 전환
      function selectNoteForEdit(note) {
        // 카드 선택 표시
        document.querySelectorAll('.note-card').forEach(card => {
          card.classList.remove('selected');
        });
        document.querySelector(`[data-note-id="${note.id}"]`).classList.add('selected');

        // 편집 페이지로 전환
        switchToPage('editor');
        
        // 폼에 데이터 채우기
        fillMainForm(note);
        
        // 조회 모드로 설정
        setViewMode(note);
      }

      // 작성 모드 설정
      function setWriteMode() {
        isViewMode = false;
        isEditMode = false;
        selectedNoteId = null;
        
        document.getElementById('saveMainBtn').disabled = false;
        document.getElementById('editMainBtn').disabled = true;
        document.getElementById('deleteMainBtn').disabled = true;
        
        setFormEnabled(true);
        
        // 카드 선택 해제
        document.querySelectorAll('.note-card').forEach(card => {
          card.classList.remove('selected');
        });
      }

      // 조회 모드 설정
      function setViewMode(note) {
        isViewMode = true;
        isEditMode = false;
        selectedNoteId = note.id;
        
        const canEdit = note.직원번호 === currentUser || currentUser === 'admin' || currentUser === 's25001';
        
        document.getElementById('saveMainBtn').disabled = true;
        document.getElementById('editMainBtn').disabled = !canEdit;
        document.getElementById('deleteMainBtn').disabled = !canEdit;
        
        setFormEnabled(true, true);
      }

      // 폼 활성화/비활성화
      function setFormEnabled(enabled, readOnlyMode = false) {
        const formElements = document.querySelectorAll('#mainNoteForm input, #mainNoteForm textarea');
        formElements.forEach(element => {
          if (element.id === 'mainNumber') {
            element.disabled = true;
          } else if (readOnlyMode) {
            element.disabled = false;
          } else {
            element.disabled = !enabled;
          }
        });
        
        document.querySelectorAll('#mainNoteForm input[type="radio"]').forEach(radio => {
          if (readOnlyMode) {
            radio.disabled = false;
          } else {
            radio.disabled = !enabled;
          }
        });
        
        // 게시여부 라디오 버튼들 (폼 외부)
        document.querySelectorAll('input[name="publish"]').forEach(radio => {
          if (readOnlyMode) {
            // 조회 모드에서는 권한 확인
            const canEdit = selectedNoteId && canEditNote();
            radio.disabled = !canEdit;
          } else {
            radio.disabled = !enabled;
          }
        });
        
        document.querySelectorAll('.tag-example-btn[data-target="mainTag"]').forEach(btn => {
          if (readOnlyMode) {
            btn.disabled = false;
          } else {
            btn.disabled = !enabled;
          }
        });
      }

      // 메인 폼에 데이터 채우기
      function fillMainForm(note) {
        const categoryRadio = document.querySelector(`input[name="category"][value="${note.구분}"]`);
        if (categoryRadio) categoryRadio.checked = true;
        
        const formattedDate = formatDateForInput(note.노트날짜 || '');
        document.getElementById('mainDate').value = formattedDate;
        
        document.getElementById('mainNumber').value = note.노트번호 || '';
        
        if (window.setTags_mainTag) {
          window.setTags_mainTag(note.태그 || '');
        }
        
        const contentTextarea = document.getElementById('mainContent');
        contentTextarea.value = note.노트내용 || '';
        
        // 내용이 채워진 후 높이 조정
        autoResizeTextarea(contentTextarea);
        
        const publishRadio = document.querySelector(`input[name="publish"][value="${note.게시여부 || 'Y'}"]`);
        if (publishRadio) publishRadio.checked = true;
      }

      // 메인 폼 초기화
      async function resetMainForm() {
        document.getElementById('mainNoteForm').reset();
        
        document.querySelector('input[name="category"][value="센터장"]').checked = true;        
        document.querySelector('input[name="publish"][value="Y"]').checked = true;
        
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('mainDate').value = today;
        
        if (window.setTags_mainTag) {
          window.setTags_mainTag('');
        }
        
        // 노트내용 textarea 높이 초기화
        const contentTextarea = document.getElementById('mainContent');
        if (contentTextarea) {
          autoResizeTextarea(contentTextarea);
        }
        
        await updateNoteNumber();
        setWriteMode();
      }

      // 노트번호 업데이트
      async function updateNoteNumber() {
        const dateValue = document.getElementById('mainDate').value;
        if (dateValue && currentUser) {
          try {
            const formattedDate = formatDateForStorage(dateValue);
            const noteNumber = await generateNoteNumber(currentUser, formattedDate);
            document.getElementById('mainNumber').value = noteNumber;
          } catch (error) {
            console.error('노트번호 생성 실패:', error);
          }
        }
      }

      // 수정 권한 확인
      function canEditNote() {
        if (!selectedNoteId) {
          return false;
        }
        
        const selectedNote = cachedNotes.find(note => note.id === selectedNoteId);
        if (!selectedNote) {
          console.error('선택된 노트를 찾을 수 없습니다:', selectedNoteId);
          return false;
        }
        
        const canEdit = selectedNote.직원번호 === currentUser || 
                       currentUser === 'admin' || 
                       currentUser === 's25001';
        
        return canEdit;
      }

      // 노트 저장 버튼 클릭 이벤트
      async function saveMainNote() {
        console.log('💾 저장 버튼 클릭');
        
        // 먼저 confirm 모달로 확인
        const confirmed = await customConfirm('노트를 저장하시겠습니까?');
        if (!confirmed) {
          return;
        }
        
        try {
          // 작업 실행 중 플래그 설정 (authCheck 우회용)
          isExecutingAction = true;
          window.isExecutingAction = true;
          
          // 폼 유효성 검사
          const form = document.getElementById('mainNoteForm');
          if (!form.checkValidity()) {
            await customAlert('모든 필수 항목을 입력하세요.');
            return;
          }

          // 노트 데이터 생성
          const noteData = {
            직원번호: currentUser,
            직원명: currentUserName,
            구분: document.querySelector('input[name="category"]:checked').value,
            노트날짜: formatDateForStorage(document.getElementById('mainDate').value),
            노트번호: document.getElementById('mainNumber').value,
            태그: window.getTags_mainTag ? window.getTags_mainTag() : '',
            노트내용: document.getElementById('mainContent').value,
            게시여부: document.querySelector('input[name="publish"]:checked').value
          };

          console.log('💾 저장 데이터:', noteData);

          // 서버에 저장 실행
          const result = await addNote(noteData);

          if (result.success) {
            // 노트 목록 다시 로드
            await loadNotes();
            
            // 편집 탭 초기화
            await resetMainForm();
            
            // 조회 탭으로 이동
            switchToPage('notes');
            
          } else {
            const errorMessage = result.error?.message || '알 수 없는 오류가 발생했습니다.';
            await customAlert('저장에 실패했습니다: ' + errorMessage);
          }

        } catch (error) {
          console.error('💥 저장 중 예외 발생:', error);
          await customAlert('저장 중 오류가 발생했습니다: ' + error.message);
        } finally {
          // 작업 완료 후 플래그 해제
          isExecutingAction = false;
          window.isExecutingAction = false;
        }
      }

      // 노트 수정 버튼 클릭 이벤트
      async function editMainNote() {
        console.log('🔧 수정 버튼 클릭');
        
        if (!selectedNoteId) {
          await customAlert('수정할 노트를 먼저 선택해주세요.');
          return;
        }
        
        if (!canEditNote()) {
          await customAlert('이 노트를 수정할 권한이 없습니다.');
          return;
        }

        // 먼저 confirm 모달로 확인
        const confirmed = await customConfirm('현재 입력된 내용으로 노트를 수정하시겠습니까?');
        if (!confirmed) {
          return;
        }
        
        try {
          // 작업 실행 중 플래그 설정 (authCheck 우회용)
          isExecutingAction = true;
          window.isExecutingAction = true;
          
          // 폼 유효성 검사
          const form = document.getElementById('mainNoteForm');
          if (!form.checkValidity()) {
            await customAlert('모든 필수 항목을 입력하세요.');
            return;
          }

          // 노트 데이터 생성
          const noteData = {
            직원번호: currentUser,
            직원명: currentUserName,
            구분: document.querySelector('input[name="category"]:checked').value,
            노트날짜: formatDateForStorage(document.getElementById('mainDate').value),
            노트번호: document.getElementById('mainNumber').value,
            태그: window.getTags_mainTag ? window.getTags_mainTag() : '',
            노트내용: document.getElementById('mainContent').value,
            게시여부: document.querySelector('input[name="publish"]:checked').value
          };

          console.log('🔄 수정 데이터:', noteData);

          // 기존 노트 삭제
          console.log('🗑️ 기존 노트 삭제 중...');
          const deleteResult = await deleteNote(selectedNoteId);
          
          if (!deleteResult.success) {
            throw new Error('기존 노트 삭제 실패: ' + (deleteResult.error?.message || '알 수 없는 오류'));
          }
          
          console.log('✅ 기존 노트 삭제 완료');

          // 새로운 데이터로 저장
          console.log('💾 새로운 데이터로 저장 중...');
          const addResult = await addNote(noteData);
          
          if (!addResult.success) {
            throw new Error('새 노트 저장 실패: ' + (addResult.error?.message || '알 수 없는 오류'));
          }
          
          console.log('✅ 새 노트 저장 완료');

          // 노트 목록 다시 로드
          await loadNotes();
          
          // 편집 탭 초기화
          await resetMainForm();
          
          // 조회 탭으로 이동
          switchToPage('notes');

        } catch (error) {
          console.error('💥 수정 중 예외 발생:', error);
          await customAlert('수정 중 오류가 발생했습니다: ' + error.message);
        } finally {
          // 작업 완료 후 플래그 해제
          isExecutingAction = false;
          window.isExecutingAction = false;
        }
      }

      // 노트 삭제 버튼 클릭 이벤트
      async function deleteMainNote() {
        console.log('🗑️ 삭제 버튼 클릭');
        
        if (!selectedNoteId) {
          await customAlert('삭제할 노트를 선택하세요.');
          return;
        }

        if (!canEditNote()) {
          await customAlert('이 노트를 삭제할 권한이 없습니다.');
          return;
        }

        // 먼저 confirm 모달로 확인
        const confirmed = await customConfirm('정말로 삭제하시겠습니까?');
        if (!confirmed) {
          return;
        }

        try {
          // 작업 실행 중 플래그 설정 (authCheck 우회용)
          isExecutingAction = true;
          window.isExecutingAction = true;
          
          // 서버에서 노트 삭제 실행
          const result = await deleteNote(selectedNoteId);
          
          if (result.success) {
            // 노트 목록 다시 로드
            await loadNotes();
            
            // 편집 탭 초기화
            await resetMainForm();
            
            // 조회 탭으로 이동
            switchToPage('notes');
            
          } else {
            await customAlert('삭제에 실패했습니다: ' + (result.error?.message || '알 수 없는 오류'));
          }
          
        } catch (error) {
          console.error('💥 삭제 중 예외 발생:', error);
          await customAlert('삭제 중 오류가 발생했습니다: ' + error.message);
        } finally {
          // 작업 완료 후 플래그 해제
          isExecutingAction = false;
          window.isExecutingAction = false;
        }
      }

      // 검색 수행
      async function performSearch() {
        const startDate = document.getElementById('searchStartDate').value;
        const endDate = document.getElementById('searchEndDate').value;
        const tag = document.getElementById('searchTag').value.trim();
        const content = document.getElementById('searchContent').value.trim();
        const author = document.getElementById('searchAuthor').value.trim();
        const publishFilter = document.querySelector('input[name="publishFilter"]:checked').value;

        try {
          if (!isValidEmployee(currentUser)) {
            console.log('🚫 직원명단에 없는 사용자입니다. 페이지 전체를 비활성화합니다.');
            cachedNotes = [];
            displayNotes(cachedNotes);
            disablePageForUnauthorizedUser(); // 페이지 전체 비활성화
            return;
          }

          if (hasDateRangeChanged(startDate, endDate)) {
            console.log('날짜 범위 변경됨 - 서버에서 새로 조회');
            
            currentDateRange.startDate = startDate;
            currentDateRange.endDate = endDate;
            
            cachedNotes = await getNoteshareDataByDateRange(currentUser, startDate, endDate);
            console.log('새로 조회된 노트 수:', cachedNotes.length);
          }
          
          let filteredNotes = applyPublishFilter(cachedNotes, publishFilter);
          
          const clientFilters = { tag, content, author };
          filteredNotes = applyClientSideFilters(filteredNotes, clientFilters);
          
          console.log('최종 필터링된 노트 수:', filteredNotes.length);
          
          notes = filteredNotes;
          displayNotes(notes);
          
        } catch (error) {
          console.error('검색 실패:', error);
          await customAlert('검색에 실패했습니다.');
        }
      }

      // 검색 초기화
      function resetSearch() {
        const dateRange = initializeDateRange(); // 2주 범위로 초기화
        document.getElementById('searchStartDate').value = dateRange.startDate;
        document.getElementById('searchEndDate').value = dateRange.endDate;
        
        document.getElementById('searchTag').value = '';
        document.getElementById('searchContent').value = '';
        document.getElementById('searchAuthor').value = '';
        
        document.querySelector('input[name="publishFilter"][value="published"]').checked = true;
        
        loadNotes();
      }

      // 태그 입력 설정
      function setupTagInput(inputId, chipsId, hiddenId) {
        const input = document.getElementById(inputId);
        const chipsContainer = document.getElementById(chipsId);
        const hiddenInput = document.getElementById(hiddenId);
        
        if (!input || !chipsContainer || !hiddenInput) return;

        let tags = [];

        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter' || e.key === ',') {
            e.preventDefault();
            addTagChip(input.value.trim());
          } else if (e.key === 'Backspace' && input.value === '' && tags.length > 0) {
            removeTagChip(tags.length - 1);
          }
        });

        input.addEventListener('blur', function() {
          if (input.value.trim()) {
            addTagChip(input.value.trim());
          }
        });

        function addTagChip(tagText) {
          if (!tagText || tags.includes(tagText)) return;

          tags.push(tagText);
          input.value = '';
          updateChipsDisplay();
          updateHiddenInput();
        }

        function removeTagChip(index) {
          tags.splice(index, 1);
          updateChipsDisplay();
          updateHiddenInput();
        }

        function updateChipsDisplay() {
          chipsContainer.innerHTML = '';
          if (tags.length > 0) {
            tags.forEach((tag, index) => {
              const chip = document.createElement('div');
              chip.className = 'tag-chip';
              chip.innerHTML = `
                <span>${tag}</span>
                <button type="button" class="tag-remove" onclick="removeTagByIndex(${index}, '${inputId}')">&times;</button>
              `;
              chipsContainer.appendChild(chip);
            });
            chipsContainer.style.display = 'flex';
          } else {
            chipsContainer.style.display = 'none';
          }
        }

        function updateHiddenInput() {
          hiddenInput.value = tags.join(', ');
        }

        window[`removeTagByIndex_${inputId}`] = removeTagChip;
        window.removeTagByIndex = function(index, targetInputId) {
          if (targetInputId === inputId) {
            removeTagChip(index);
          }
        };

        window[`setTags_${inputId}`] = function(tagString) {
          tags = tagString ? tagString.split(',').map(t => t.trim()).filter(t => t) : [];
          updateChipsDisplay();
          updateHiddenInput();
        };

        window[`getTags_${inputId}`] = function() {
          return tags.join(', ');
        };

        updateChipsDisplay();
      }

      // 태그 예시에서 태그 추가
      function addTagFromExample(tag, targetId = 'mainTag') {
        if (targetId === 'mainTag') {
          const input = document.getElementById(targetId);
          input.value = tag;
          const event = new KeyboardEvent('keydown', { key: 'Enter' });
          input.dispatchEvent(event);
          
          // 회원상담 태그일 경우 노트내용에 템플릿 추가
          if (tag === '회원상담') {
            const contentTextarea = document.getElementById('mainContent');
                const template = `1. 상담일시 : 

2. 기본정보 :
 - 보호자명 및 연락처 : 
 - 어르신 명 :
 - 요양등급 : 
 - 나이 :
 - 주소 :

3. 어르신 진단 :

4. 기능상태 :

5. 시설이용 특이사항 : 

6. 기타 요구사항 등 :`;
            
            // 기존 내용이 있으면 줄바꿈 후 추가, 없으면 바로 추가
            if (contentTextarea.value.trim()) {
              contentTextarea.value += '\n\n' + template;
            } else {
              contentTextarea.value = template;
            }
            
            // 템플릿 추가 후 높이 조정
            autoResizeTextarea(contentTextarea);
          }
        }
      }

      // 커스텀 Alert 함수
      function customAlert(message) {
        return new Promise((resolve) => {
          const modal = document.getElementById('customAlertModal');
          const messageElement = document.getElementById('alertMessage');
          const okBtn = document.getElementById('alertOkBtn');
          
          messageElement.textContent = message;
          modal.style.display = 'block';
          
          function closeAlert() {
            modal.style.display = 'none';
            okBtn.removeEventListener('click', closeAlert);
            document.removeEventListener('keydown', handleKeyDown);
            resolve();
          }
          
          function handleKeyDown(e) {
            if (e.key === 'Enter' || e.key === 'Escape') {
              closeAlert();
            }
          }
          
          okBtn.addEventListener('click', closeAlert);
          document.addEventListener('keydown', handleKeyDown);
          
          setTimeout(() => okBtn.focus(), 100);
        });
      }

      // 커스텀 Confirm 함수
      function customConfirm(message) {
        return new Promise((resolve) => {
          const modal = document.getElementById('customConfirmModal');
          const messageElement = document.getElementById('confirmMessage');
          const okBtn = document.getElementById('confirmOkBtn');
          const cancelBtn = document.getElementById('confirmCancelBtn');
          
          messageElement.textContent = message;
          modal.style.display = 'block';
          
          function closeConfirm(result) {
            modal.style.display = 'none';
            okBtn.removeEventListener('click', handleOk);
            cancelBtn.removeEventListener('click', handleCancel);
            document.removeEventListener('keydown', handleKeyDown);
            resolve(result);
          }
          
          function handleOk() {
            closeConfirm(true);
          }
          
          function handleCancel() {
            closeConfirm(false);
          }
          
          function handleKeyDown(e) {
            if (e.key === 'Enter') {
              closeConfirm(true);
            } else if (e.key === 'Escape') {
              closeConfirm(false);
            }
          }
          
          okBtn.addEventListener('click', handleOk);
          cancelBtn.addEventListener('click', handleCancel);
          document.addEventListener('keydown', handleKeyDown);
          
          setTimeout(() => cancelBtn.focus(), 100);
        });
      }

      // 기존 alert와 confirm을 커스텀 모달로 대체
      window.alert = customAlert;
      window.confirm = customConfirm;



      // 페이지 로딩 시 textarea 최적 높이 계산 함수
      function calculateOptimalTextareaHeight() {
        try {
          const textarea = document.getElementById('mainContent');
          if (!textarea) return;

          // 전체 뷰포트 높이
          const viewportHeight = window.innerHeight;
          
          // 상단 요소들의 높이 계산
          const navHeight = 45; // --nav-height CSS 변수값
          const headerHeight = 50; // --header-height CSS 변수값
          
          // 편집 페이지의 다른 요소들 높이 계산
          const editorSection = document.querySelector('.editor-section');
          if (!editorSection) return;
          
          // textarea를 제외한 다른 폼 요소들의 높이 계산
          const formGroups = editorSection.querySelectorAll('.form-group:not(.textarea-container)');
          let otherElementsHeight = 0;
          
          formGroups.forEach(group => {
            otherElementsHeight += group.offsetHeight || 0;
          });
          
          // 버튼 섹션 높이
          const buttonSection = editorSection.querySelector('.button-section');
          if (buttonSection) {
            otherElementsHeight += buttonSection.offsetHeight || 0;
          }
          
          // 패딩과 마진 여유공간 (약 60px)
          const paddingMarginSpace = 60;
          
          // 사용 가능한 높이 계산
          const availableHeight = viewportHeight - navHeight - headerHeight - otherElementsHeight - paddingMarginSpace;
          
          // 최소 높이와 최대 높이 제한
          const minHeight = 120;
          const maxHeight = Math.max(availableHeight, minHeight);
          
          // textarea 높이 설정
          textarea.style.height = maxHeight + 'px';
          
          console.log('📐 Textarea 최적 높이 계산:', {
            viewportHeight: viewportHeight,
            navHeight: navHeight,
            headerHeight: headerHeight,
            otherElementsHeight: otherElementsHeight,
            availableHeight: availableHeight,
            finalHeight: maxHeight
          });
          
        } catch (error) {
          console.error('Textarea 높이 계산 중 오류:', error);
        }
      }

      // textarea 높이 자동 조정 함수 - 완전히 새로운 구현
      function autoResizeTextarea(textarea) {
        if (!textarea) return;
        
        // 페이지 로딩 시에는 최적 높이를 계산
        if (!textarea.value || textarea.value.trim() === '') {
          calculateOptimalTextareaHeight();
          return;
        }
        
        // 임시로 높이를 auto로 설정하여 실제 내용 높이 측정
        const originalHeight = textarea.style.height;
        textarea.style.height = 'auto';
        
        // 실제 스크롤 높이 측정
        const scrollHeight = textarea.scrollHeight;
        const minHeight = 120;
        
        // 최종 높이 계산
        const finalHeight = Math.max(scrollHeight, minHeight);
        
        // 높이 적용
        textarea.style.height = finalHeight + 'px';
        
        // 콘솔에 디버깅 정보 출력
        console.log('📏 Textarea 높이 자동 조정:', {
          scrollHeight: scrollHeight,
          minHeight: minHeight,
          finalHeight: finalHeight,
          previousHeight: originalHeight
        });
        
        // 높이 변경 후 스크롤 조정
        requestAnimationFrame(() => {
          if (document.activeElement === textarea) {
            textarea.scrollIntoView({ 
              behavior: 'smooth', 
              block: 'nearest' 
            });
          }
        });
      }

      // 부드러운 스크롤을 아래로 내리는 함수
      function scrollToBottomSmooth() {
        try {
          // 현재 활성화된 페이지 확인
          const activePage = document.querySelector('.page.active');
          if (!activePage) return;

          // 편집 페이지인 경우에만 스크롤
          if (activePage.id === 'editorPage') {
            const textarea = document.getElementById('mainContent');
            if (textarea) {
              // 텍스트 영역을 화면에 보이도록 스크롤
              textarea.scrollIntoView({
                behavior: 'smooth',
                block: 'end',
                inline: 'nearest'
              });

              // 추가로 에디터 섹션도 아래로 스크롤
              const editorSection = activePage.querySelector('.editor-section');
              if (editorSection) {
                setTimeout(() => {
                  editorSection.scrollTo({
                    top: editorSection.scrollHeight,
                    behavior: 'smooth'
                  });
                }, 200);
              }
            }
          }
        } catch (error) {
          console.error('스크롤 이동 중 오류:', error);
        }
      }

      // 초기 폼 설정
      async function initializeForm() {
        const today = new Date().toISOString().split('T')[0];
        document.getElementById('mainDate').value = today;
        
        await updateNoteNumber();
        setWriteMode();
        
        // 페이지 로딩 시 textarea 최적 높이 계산
        setTimeout(() => {
          calculateOptimalTextareaHeight();
        }, 200);
      }

      // 이벤트 리스너 설정
      function setupEventListeners() {
        // 네비게이션 버튼 이벤트
        document.getElementById('notesPageBtn').addEventListener('click', () => {
          switchToPage('notes');
        });
        
        document.getElementById('editorPageBtn').addEventListener('click', () => {
          switchToPage('editor');
        });

        // 검색 기능
        document.getElementById('searchBtn').addEventListener('click', performSearch);
        document.getElementById('resetBtn').addEventListener('click', resetSearch);
        
        // 검색 입력 필드들의 Enter 키 이벤트
        ['searchTag', 'searchContent', 'searchAuthor'].forEach(id => {
          const element = document.getElementById(id);
          if (element) {
            element.addEventListener('keypress', function(e) {
              if (e.key === 'Enter') {
                performSearch();
              }
            });
          }
        });

        // 게시여부 필터 변경 시 자동 검색
        document.querySelectorAll('input[name="publishFilter"]').forEach(radio => {
          radio.addEventListener('change', performSearch);
        });

        // 메인 폼 버튼 이벤트
        document.getElementById('saveMainBtn').addEventListener('click', function(e) {
          e.preventDefault(); // 폼 제출 방지
          console.log('🖱️ 저장 버튼 클릭됨!');
          saveMainNote();
        });
        document.getElementById('editMainBtn').addEventListener('click', function(e) {
          e.preventDefault(); // 폼 제출 방지
          editMainNote();
        });
        document.getElementById('deleteMainBtn').addEventListener('click', function(e) {
          e.preventDefault(); // 폼 제출 방지
          deleteMainNote();
        });
        document.getElementById('resetMainBtn').addEventListener('click', function(e) {
          e.preventDefault(); // 폼 제출 방지
          resetMainForm();
        });

        // 날짜 변경 시 노트번호 업데이트
        document.getElementById('mainDate').addEventListener('change', updateNoteNumber);

        // 태그 입력 이벤트
        setupTagInput('mainTag', 'mainTagChips', 'mainTagHidden');

        // 태그 예시 버튼 이벤트
        document.querySelectorAll('.tag-example-btn').forEach(btn => {
          btn.addEventListener('click', function() {
            const target = this.dataset.target || 'mainTag';
            addTagFromExample(this.dataset.tag, target);
          });
        });

        // 노트내용 입력 필드 자동 높이 조정 시스템 - 완전히 새로운 구현
        const mainContentTextarea = document.getElementById('mainContent');
        if (mainContentTextarea) {
          console.log('🚀 Textarea 자동 높이 시스템 초기화');
          
          // 초기 높이 설정
          autoResizeTextarea(mainContentTextarea);

          // input 이벤트 - 타이핑할 때마다 높이 조정
          mainContentTextarea.addEventListener('input', function() {
            console.log('⌨️ Input 이벤트 발생');
            autoResizeTextarea(this);
          });

          // 붙여넣기 이벤트
          mainContentTextarea.addEventListener('paste', function() {
            console.log('📋 Paste 이벤트 발생');
            // 붙여넣기 내용이 반영된 후 높이 조정
            setTimeout(() => {
              autoResizeTextarea(this);
            }, 50);
          });

          // 키보드 이벤트 (Enter, Backspace 등)
          mainContentTextarea.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === 'Backspace' || e.key === 'Delete') {
              setTimeout(() => {
                autoResizeTextarea(this);
              }, 10);
            }
          });

          // 포커스 이벤트
          mainContentTextarea.addEventListener('focus', function() {
            console.log('🎯 Focus 이벤트 발생');
            autoResizeTextarea(this);
            
            // 모바일 키보드 대응
            setTimeout(() => {
              scrollToBottomSmooth();
            }, 500);
          });

          // 창 크기 변경 시에도 높이 재조정
          window.addEventListener('resize', function() {
            // 편집 페이지가 활성화된 경우에만 실행
            if (currentPage === 'editor') {
              setTimeout(() => {
                if (document.activeElement === mainContentTextarea) {
                  autoResizeTextarea(mainContentTextarea);
                } else {
                  // 포커스가 없을 때는 최적 높이 재계산
                  calculateOptimalTextareaHeight();
                }
              }, 100);
            }
          });
        }

        // 뷰포트 크기 변경 감지 (모바일 키보드 대응)
        let initialViewportHeight = window.innerHeight;
        window.addEventListener('resize', function() {
          // 키보드가 올라와서 뷰포트가 줄어든 경우
          if (window.innerHeight < initialViewportHeight * 0.8) {
            const activeElement = document.activeElement;
            if (activeElement && activeElement.id === 'mainContent') {
              setTimeout(() => {
                scrollToBottomSmooth();
              }, 300);
            }
          } else {
            // 키보드가 내려간 경우 초기 높이 업데이트
            initialViewportHeight = window.innerHeight;
          }
        });

        // 브라우저 탭 활성화 시 사용자 정보 재확인
        document.addEventListener('visibilitychange', function() {
          if (document.hidden) {
            console.log('🔒 탭 비활성화 - 보안 모드');
          } else {
            console.log('👁️ 탭 활성화 - 사용자 정보 재확인');
            // 탭이 다시 활성화될 때 사용자 정보 재확인 (작업 실행 중이거나 탭 전환 중이 아닐 때만)
            setTimeout(async () => {
              if (!isExecutingAction && !isSwitchingTab) {
                await getUserFromParent(false);
                await loadUserInfo();
              }
            }, 100);
          }
        });
      }

      // 모바일 환경 감지 및 오류 처리 강화
      function isMobileDevice() {
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }

      // 안전한 초기화 함수
      async function safeInitialize() {
        try {
          console.log('📱 모바일 환경에서 안전한 초기화 시작');
          
          // Supabase 로딩 확인
          if (typeof window.supabase === 'undefined') {
            console.error('❌ Supabase가 로드되지 않았습니다.');
            showErrorMessage('네트워크 연결을 확인하고 새로고침해주세요.');
            return;
          }

          // 1. 직원 정보 캐시 초기화 (가장 먼저)
          console.log('📋 직원 정보 캐시 초기화...');
          await initializeEmployeesCache();
          
          // 2. parent page에서 사번 가져오기
          console.log('👤 사용자 정보 가져오기...');
          await getUserFromParent(false);

          // 3. 현재 사용자 정보 설정
          console.log('🔍 사용자 정보 로드...');
          await loadUserInfo();
          
          // 4. 날짜 범위 초기화 및 UI 설정
          console.log('📅 날짜 범위 초기화...');
          const dateRange = initializeDateRange();
          const startDateEl = document.getElementById('searchStartDate');
          const endDateEl = document.getElementById('searchEndDate');
          if (startDateEl) startDateEl.value = dateRange.startDate;
          if (endDateEl) endDateEl.value = dateRange.endDate;
          
          // 5. 노트 목록 로드
          console.log('📝 노트 목록 로드...');
          await loadNotes();

          // 6. 초기 설정
          console.log('⚙️ 폼 초기화...');
          await initializeForm();

          // 7. 이벤트 리스너 등록
          console.log('🎯 이벤트 리스너 등록...');
          setupEventListeners();

          console.log('✅ 모바일 환경 초기화 완료');
          
        } catch (error) {
          console.error('💥 초기화 중 오류 발생:', error);
          showErrorMessage('앱 초기화 중 오류가 발생했습니다. 새로고침을 시도해주세요.');
        }
      }

      // 오류 메시지 표시 함수
      function showErrorMessage(message) {
        const errorDiv = document.createElement('div');
        errorDiv.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          color: white;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10000;
          font-family: "Noto Sans KR", sans-serif;
          text-align: center;
          padding: 20px;
          box-sizing: border-box;
        `;
        errorDiv.innerHTML = `
          <div style="background: #fff; color: #333; padding: 20px; border-radius: 10px; max-width: 300px;">
            <h3 style="color: #e74c3c; margin-bottom: 15px;">⚠️ 오류</h3>
            <p style="margin-bottom: 15px; line-height: 1.4;">${message}</p>
            <button onclick="location.reload()" style="background: #3498db; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">새로고침</button>
          </div>
        `;
        document.body.appendChild(errorDiv);
      }

      // 페이지 로드 시 초기화
      document.addEventListener('DOMContentLoaded', function() {
        console.log('📱 모바일 페이지 로드 감지');
        console.log('🌐 User Agent:', navigator.userAgent);
        console.log('📊 화면 크기:', window.innerWidth + 'x' + window.innerHeight);
        console.log('🔗 현재 URL:', window.location.href);
        console.log('🌍 온라인 상태:', navigator.onLine);
        
        // 네트워크 연결 상태 체크
        if (!navigator.onLine) {
          showErrorMessage('인터넷 연결이 없습니다. 네트워크 연결을 확인해주세요.');
          return;
        }
        
        // 약간의 지연 후 초기화 (모바일에서 안정성 향상)
        setTimeout(safeInitialize, 100);
      });

      // 온라인/오프라인 상태 감지
      window.addEventListener('online', function() {
        console.log('🌍 네트워크 연결됨');
      });

      window.addEventListener('offline', function() {
        console.log('🚫 네트워크 연결 끊어짐');
        showErrorMessage('인터넷 연결이 끊어졌습니다. 네트워크 연결을 확인해주세요.');
      });
    </script>
  </body>
</html>